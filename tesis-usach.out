\BOOKMARK [0][]{chapter.1}{1 Introducción}{}% 1
\BOOKMARK [1][]{section.1.1}{1.1 Antecedentes y motivación}{chapter.1}% 2
\BOOKMARK [1][]{section.1.2}{1.2 Descripción del problema}{chapter.1}% 3
\BOOKMARK [1][]{section.1.3}{1.3 Solución Propuesta}{chapter.1}% 4
\BOOKMARK [2][]{subsection.1.3.1}{1.3.1 Características de la solución}{section.1.3}% 5
\BOOKMARK [2][]{subsection.1.3.2}{1.3.2 Propósitos de la solución}{section.1.3}% 6
\BOOKMARK [1][]{section.1.4}{1.4\040Objetivos\040y\040alcance\040del\040proyecto}{chapter.1}% 7
\BOOKMARK [2][]{subsection.1.4.1}{1.4.1\040Objetivo\040general}{section.1.4}% 8
\BOOKMARK [2][]{subsection.1.4.2}{1.4.2 Objetivos específicos}{section.1.4}% 9
\BOOKMARK [1][]{section.1.5}{1.5 Metodologías y herramientas utilizadas}{chapter.1}% 10
\BOOKMARK [2][]{subsection.1.5.1}{1.5.1 Metodología a usar}{section.1.5}% 11
\BOOKMARK [2][]{subsection.1.5.2}{1.5.2\040Herramientas\040de\040Software}{section.1.5}% 12
\BOOKMARK [2][]{subsection.1.5.3}{1.5.3\040Herramientas\040de\040Hardware}{section.1.5}% 13
\BOOKMARK [1][]{section.1.6}{1.6 Organización del documento}{chapter.1}% 14
\BOOKMARK [0][]{chapter.2}{2 Marco teórico}{}% 15
\BOOKMARK [1][]{section.2.1}{2.1\040Marco\040conceptual}{chapter.2}% 16
\BOOKMARK [2][]{subsection.2.1.1}{2.1.1\040API}{section.2.1}% 17
\BOOKMARK [2][]{subsection.2.1.2}{2.1.2\040SDK}{section.2.1}% 18
\BOOKMARK [2][]{subsection.2.1.3}{2.1.3 Tipos de aplicaciones móviles}{section.2.1}% 19
\BOOKMARK [3][]{subsubsection.2.1.3.1}{2.1.3.1\040Nativas}{subsection.2.1.3}% 20
\BOOKMARK [3][]{subsubsection.2.1.3.2}{2.1.3.2\040Web}{subsection.2.1.3}% 21
\BOOKMARK [3][]{subsubsection.2.1.3.3}{2.1.3.3 Híbridas}{subsection.2.1.3}% 22
\BOOKMARK [1][]{section.2.2}{2.2\040Estado\040del\040arte}{chapter.2}% 23
\BOOKMARK [2][]{subsection.2.2.1}{2.2.1\040OpenGlove}{section.2.2}% 24
\BOOKMARK [2][]{subsection.2.2.2}{2.2.2\040AvatarVR}{section.2.2}% 25
\BOOKMARK [2][]{subsection.2.2.3}{2.2.3\040Dexmo}{section.2.2}% 26
\BOOKMARK [2][]{subsection.2.2.4}{2.2.4\040Manus\040VR}{section.2.2}% 27
\BOOKMARK [2][]{subsection.2.2.5}{2.2.5\040Haptx}{section.2.2}% 28
\BOOKMARK [1][]{section.2.3}{2.3\040Resumen}{chapter.2}% 29
\BOOKMARK [0][]{chapter.3}{3 Análisis}{}% 30
\BOOKMARK [1][]{section.3.1}{3.1\040Levantamiento\040de\040requisitos\040de\040software}{chapter.3}% 31
\BOOKMARK [2][]{subsection.3.1.1}{3.1.1\040Antecedentes}{section.3.1}% 32
\BOOKMARK [2][]{subsection.3.1.2}{3.1.2\040Requisitos}{section.3.1}% 33
\BOOKMARK [1][]{section.3.2}{3.2\040Prototipos}{chapter.3}% 34
\BOOKMARK [2][]{subsection.3.2.1}{3.2.1 Primer prototipo: Activación de motores}{section.3.2}% 35
\BOOKMARK [2][]{subsection.3.2.2}{3.2.2 Segundo prototipo: Obtención de datos desde flexores}{section.3.2}% 36
\BOOKMARK [2][]{subsection.3.2.3}{3.2.3\040Tercer\040prototipo}{section.3.2}% 37
\BOOKMARK [2][]{subsection.3.2.4}{3.2.4\040Cuarto\040prototipo}{section.3.2}% 38
\BOOKMARK [2][]{subsection.3.2.5}{3.2.5\040Quinto\040prototipo}{section.3.2}% 39
\BOOKMARK [1][]{section.3.3}{3.3\040APIs}{chapter.3}% 40
\BOOKMARK [2][]{subsection.3.3.1}{3.3.1\040Primer\040prototipo?}{section.3.3}% 41
\BOOKMARK [2][]{subsection.3.3.2}{3.3.2\040Segundo\040prototipo}{section.3.3}% 42
\BOOKMARK [2][]{subsection.3.3.3}{3.3.3\040Tercer\040prototipo}{section.3.3}% 43
\BOOKMARK [2][]{subsection.3.3.4}{3.3.4\040Cuarto\040prototipo}{section.3.3}% 44
\BOOKMARK [1][]{section.3.4}{3.4\040Resumen}{chapter.3}% 45
\BOOKMARK [0][]{chapter.4}{4 Diseño e implementación}{}% 46
\BOOKMARK [1][]{section.4.1}{4.1\040Arquitectura\040general}{chapter.4}% 47
\BOOKMARK [1][]{section.4.2}{4.2\040Estructura}{chapter.4}% 48
\BOOKMARK [2][]{subsection.4.2.1}{4.2.1\040Servicio}{section.4.2}% 49
\BOOKMARK [2][]{subsection.4.2.2}{4.2.2\040APIs}{section.4.2}% 50
\BOOKMARK [2][]{subsection.4.2.3}{4.2.3 Software de configuración}{section.4.2}% 51
\BOOKMARK [1][]{section.4.3}{4.3\040Comportamiento}{chapter.4}% 52
\BOOKMARK [2][]{subsection.4.3.1}{4.3.1\040Obtener\040guantes}{section.4.3}% 53
\BOOKMARK [2][]{subsection.4.3.2}{4.3.2 Activación}{section.4.3}% 54
\BOOKMARK [2][]{subsection.4.3.3}{4.3.3 Añadir flexor a una región}{section.4.3}% 55
\BOOKMARK [2][]{subsection.4.3.4}{4.3.4\040Asignar\040Threshold}{section.4.3}% 56
\BOOKMARK [2][]{subsection.4.3.5}{4.3.5\040Iniciar\040IMU}{section.4.3}% 57
\BOOKMARK [2][]{subsection.4.3.6}{4.3.6\040Lectura\040de\040datos\040provenientes\040de\040Arduino}{section.4.3}% 58
\BOOKMARK [1][]{section.4.4}{4.4 Aspectos de implementación}{chapter.4}% 59
\BOOKMARK [2][]{subsection.4.4.1}{4.4.1\040Desarrollo\040multiplataforma\040en\040Xamarin.Forms}{section.4.4}% 60
\BOOKMARK [2][]{subsection.4.4.2}{4.4.2\040Servicio}{section.4.4}% 61
\BOOKMARK [2][]{subsection.4.4.3}{4.4.3 Software de configuración}{section.4.4}% 62
\BOOKMARK [2][]{subsection.4.4.4}{4.4.4\040APIs}{section.4.4}% 63
\BOOKMARK [3][]{subsubsection.4.4.4.1}{4.4.4.1\040Java}{subsection.4.4.4}% 64
\BOOKMARK [3][]{subsubsection.4.4.4.2}{4.4.4.2\040C#}{subsection.4.4.4}% 65
\BOOKMARK [1][]{section.4.5}{4.5\040Resumen}{chapter.4}% 66
\BOOKMARK [0][]{chapter.5}{5 Evaluación técnica}{}% 67
\BOOKMARK [1][]{section.5.1}{5.1 Evaluación aplicaciones nativa y multiplataforma}{chapter.5}% 68
\BOOKMARK [2][]{subsection.5.1.1}{5.1.1\040Prototipo\0403\040:\040Droid\040-\040Galaxy}{section.5.1}% 69
\BOOKMARK [3][]{subsubsection.5.1.1.1}{5.1.1.1\040Motores}{subsection.5.1.1}% 70
\BOOKMARK [3][]{subsubsection.5.1.1.2}{5.1.1.2\040Flexores}{subsection.5.1.1}% 71
\BOOKMARK [2][]{subsection.5.1.2}{5.1.2\040Prototipo\0404:\040Xamarin\040-\040Galaxy}{section.5.1}% 72
\BOOKMARK [3][]{subsubsection.5.1.2.1}{5.1.2.1\040Motores}{subsection.5.1.2}% 73
\BOOKMARK [3][]{subsubsection.5.1.2.2}{5.1.2.2\040Flexores}{subsection.5.1.2}% 74
\BOOKMARK [2][]{subsection.5.1.3}{5.1.3\040Prototipo\0403\040:\040Droid\040-\040Nexus}{section.5.1}% 75
\BOOKMARK [3][]{subsubsection.5.1.3.1}{5.1.3.1\040Motores}{subsection.5.1.3}% 76
\BOOKMARK [3][]{subsubsection.5.1.3.2}{5.1.3.2\040Flexores}{subsection.5.1.3}% 77
\BOOKMARK [2][]{subsection.5.1.4}{5.1.4\040Prototipo\0404:\040Xamarin\040-\040Nexus}{section.5.1}% 78
\BOOKMARK [3][]{subsubsection.5.1.4.1}{5.1.4.1\040Motores}{subsection.5.1.4}% 79
\BOOKMARK [3][]{subsubsection.5.1.4.2}{5.1.4.2\040Flexores}{subsection.5.1.4}% 80
\BOOKMARK [1][]{section.5.2}{5.2 Evaluación tiempo de activación}{chapter.5}% 81
\BOOKMARK [2][]{subsection.5.2.1}{5.2.1\040API\040C#}{section.5.2}% 82
\BOOKMARK [2][]{subsection.5.2.2}{5.2.2\040API\040Java}{section.5.2}% 83
\BOOKMARK [1][]{section.5.3}{5.3 Evaluación tiempo de lectura de datos}{chapter.5}% 84
\BOOKMARK [2][]{subsection.5.3.1}{5.3.1\040API\040C#}{section.5.3}% 85
\BOOKMARK [2][]{subsection.5.3.2}{5.3.2\040API\040Java}{section.5.3}% 86
\BOOKMARK [1][]{section.5.4}{5.4\040Resumen}{chapter.5}% 87
\BOOKMARK [0][]{chapter.6}{6\040Conclusiones}{}% 88
\BOOKMARK [1][]{section.6.1}{6.1\040Objetivos}{chapter.6}% 89
\BOOKMARK [2][]{subsection.6.1.1}{6.1.1 Objetivos específicos}{section.6.1}% 90
\BOOKMARK [2][]{subsection.6.1.2}{6.1.2\040Objetivo\040general}{section.6.1}% 91
\BOOKMARK [1][]{section.6.2}{6.2\040Resultados\040obtenidos}{chapter.6}% 92
\BOOKMARK [2][]{subsection.6.2.1}{6.2.1\040Desarrollo\040de\040software}{section.6.2}% 93
\BOOKMARK [2][]{subsection.6.2.2}{6.2.2\040Resultados\040de\040las\040pruebas}{section.6.2}% 94
\BOOKMARK [3][]{subsubsection.6.2.2.1}{6.2.2.1\040Tiempo\040de\040respuesta}{subsection.6.2.2}% 95
\BOOKMARK [3][]{subsubsection.6.2.2.2}{6.2.2.2 Líneas de código}{subsection.6.2.2}% 96
\BOOKMARK [1][]{section.6.3}{6.3\040Alcances\040y\040limitaciones}{chapter.6}% 97
\BOOKMARK [1][]{section.6.4}{6.4\040Trabajo\040futuro}{chapter.6}% 98
\BOOKMARK [1][]{section.6.5}{6.5\040Observaciones\040finales}{chapter.6}% 99
\BOOKMARK [0][]{section.6.5}{Glosario}{}% 100
\BOOKMARK [0][]{chapter*.40}{Referencias bibliográficas}{}% 101
