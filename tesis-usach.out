\BOOKMARK [0][]{chapter.1}{1 Introducción}{}% 1
\BOOKMARK [1][]{section.1.1}{1.1 Antecedentes y motivación}{chapter.1}% 2
\BOOKMARK [1][]{section.1.2}{1.2 Descripción del problema}{chapter.1}% 3
\BOOKMARK [1][]{section.1.3}{1.3 Solución Propuesta}{chapter.1}% 4
\BOOKMARK [2][]{subsection.1.3.1}{1.3.1 Características de la solución}{section.1.3}% 5
\BOOKMARK [2][]{subsection.1.3.2}{1.3.2 Propósitos de la solución}{section.1.3}% 6
\BOOKMARK [1][]{section.1.4}{1.4\040Objetivos\040y\040alcance\040del\040proyecto}{chapter.1}% 7
\BOOKMARK [2][]{subsection.1.4.1}{1.4.1\040Objetivo\040general}{section.1.4}% 8
\BOOKMARK [2][]{subsection.1.4.2}{1.4.2 Objetivos específicos}{section.1.4}% 9
\BOOKMARK [1][]{section.1.5}{1.5 Metodologías y herramientas utilizadas}{chapter.1}% 10
\BOOKMARK [2][]{subsection.1.5.1}{1.5.1 Metodología a usar}{section.1.5}% 11
\BOOKMARK [2][]{subsection.1.5.2}{1.5.2\040Herramientas\040de\040Software}{section.1.5}% 12
\BOOKMARK [2][]{subsection.1.5.3}{1.5.3\040Herramientas\040de\040Hardware}{section.1.5}% 13
\BOOKMARK [1][]{section.1.6}{1.6 Organización del documento}{chapter.1}% 14
\BOOKMARK [0][]{chapter.2}{2 Marco teórico}{}% 15
\BOOKMARK [1][]{section.2.1}{2.1\040Marco\040conceptual}{chapter.2}% 16
\BOOKMARK [2][]{subsection.2.1.1}{2.1.1\040API}{section.2.1}% 17
\BOOKMARK [2][]{subsection.2.1.2}{2.1.2\040SDK}{section.2.1}% 18
\BOOKMARK [2][]{subsection.2.1.3}{2.1.3 Tipos de aplicaciones móviles}{section.2.1}% 19
\BOOKMARK [3][]{subsubsection.2.1.3.1}{2.1.3.1\040Nativas}{subsection.2.1.3}% 20
\BOOKMARK [3][]{subsubsection.2.1.3.2}{2.1.3.2\040Web}{subsection.2.1.3}% 21
\BOOKMARK [3][]{subsubsection.2.1.3.3}{2.1.3.3 Híbridas}{subsection.2.1.3}% 22
\BOOKMARK [2][]{subsection.2.1.4}{2.1.4\040WebSocket}{section.2.1}% 23
\BOOKMARK [1][]{section.2.2}{2.2\040Estado\040del\040arte}{chapter.2}% 24
\BOOKMARK [2][]{subsection.2.2.1}{2.2.1\040OpenGlove}{section.2.2}% 25
\BOOKMARK [2][]{subsection.2.2.2}{2.2.2\040AvatarVR}{section.2.2}% 26
\BOOKMARK [2][]{subsection.2.2.3}{2.2.3\040Dexmo}{section.2.2}% 27
\BOOKMARK [2][]{subsection.2.2.4}{2.2.4\040Manus\040VR}{section.2.2}% 28
\BOOKMARK [2][]{subsection.2.2.5}{2.2.5\040HaptX}{section.2.2}% 29
\BOOKMARK [1][]{section.2.3}{2.3\040Resumen}{chapter.2}% 30
\BOOKMARK [0][]{chapter.3}{3 Análisis}{}% 31
\BOOKMARK [1][]{section.3.1}{3.1\040Levantamiento\040de\040requisitos\040de\040software}{chapter.3}% 32
\BOOKMARK [2][]{subsection.3.1.1}{3.1.1\040Antecedentes}{section.3.1}% 33
\BOOKMARK [2][]{subsection.3.1.2}{3.1.2\040Requisitos}{section.3.1}% 34
\BOOKMARK [1][]{section.3.2}{3.2\040Prototipos}{chapter.3}% 35
\BOOKMARK [2][]{subsection.3.2.1}{3.2.1 Primer prototipo: Activación de motores}{section.3.2}% 36
\BOOKMARK [2][]{subsection.3.2.2}{3.2.2 Segundo prototipo: Obtención de datos desde los flexores}{section.3.2}% 37
\BOOKMARK [2][]{subsection.3.2.3}{3.2.3 Tercer prototipo: Activación de motores y obtención de datos desde los flexores }{section.3.2}% 38
\BOOKMARK [2][]{subsection.3.2.4}{3.2.4 Cuarto prototipo: Navegación aplicación, administración dispositivos Bluetooth, servidor WebSocket y configuración de la placa}{section.3.2}% 39
\BOOKMARK [2][]{subsection.3.2.5}{3.2.5\040Quinto\040prototipo:\040Mapeo\040de\040actuadores\040y\040prueba\040de\040actuadores}{section.3.2}% 40
\BOOKMARK [2][]{subsection.3.2.6}{3.2.6 Sexto prototipo: Mapeo de flexores, prueba de flexores y la configuración del IMU.}{section.3.2}% 41
\BOOKMARK [2][]{subsection.3.2.7}{3.2.7\040APIs}{section.3.2}% 42
\BOOKMARK [3][]{subsubsection.3.2.7.1}{3.2.7.1\040Cuarto\040prototipo}{subsection.3.2.7}% 43
\BOOKMARK [3][]{subsubsection.3.2.7.2}{3.2.7.2\040Quinto\040prototipo}{subsection.3.2.7}% 44
\BOOKMARK [3][]{subsubsection.3.2.7.3}{3.2.7.3\040Sexto\040prototipo}{subsection.3.2.7}% 45
\BOOKMARK [1][]{section.3.3}{3.3\040Resumen}{chapter.3}% 46
\BOOKMARK [0][]{chapter.4}{4 Diseño e implementación}{}% 47
\BOOKMARK [1][]{section.4.1}{4.1\040Arquitectura\040general}{chapter.4}% 48
\BOOKMARK [1][]{section.4.2}{4.2\040Estructura}{chapter.4}% 49
\BOOKMARK [2][]{subsection.4.2.1}{4.2.1\040Software\040de\040control\040Arduino}{section.4.2}% 50
\BOOKMARK [2][]{subsection.4.2.2}{4.2.2\040API\040C#\040de\040bajo\040nivel}{section.4.2}% 51
\BOOKMARK [2][]{subsection.4.2.3}{4.2.3\040APIs\040alto\040nivel}{section.4.2}% 52
\BOOKMARK [2][]{subsection.4.2.4}{4.2.4 Aplicación de configuración}{section.4.2}% 53
\BOOKMARK [1][]{section.4.3}{4.3\040Comportamiento}{chapter.4}% 54
\BOOKMARK [2][]{subsection.4.3.1}{4.3.1\040Obtener\040guantes}{section.4.3}% 55
\BOOKMARK [2][]{subsection.4.3.2}{4.3.2 Activación}{section.4.3}% 56
\BOOKMARK [2][]{subsection.4.3.3}{4.3.3 Añadir flexor a una región}{section.4.3}% 57
\BOOKMARK [2][]{subsection.4.3.4}{4.3.4\040Asignar\040Threshold}{section.4.3}% 58
\BOOKMARK [2][]{subsection.4.3.5}{4.3.5\040Iniciar\040IMU}{section.4.3}% 59
\BOOKMARK [2][]{subsection.4.3.6}{4.3.6\040Lectura\040de\040datos\040provenientes\040de\040Arduino}{section.4.3}% 60
\BOOKMARK [1][]{section.4.4}{4.4 Aspectos de implementación}{chapter.4}% 61
\BOOKMARK [2][]{subsection.4.4.1}{4.4.1\040Desarrollo\040multiplataforma\040en\040Xamarin.Forms}{section.4.4}% 62
\BOOKMARK [2][]{subsection.4.4.2}{4.4.2\040API\040C#\040bajo\040nivel}{section.4.4}% 63
\BOOKMARK [2][]{subsection.4.4.3}{4.4.3\040Servidor\040WebSocket}{section.4.4}% 64
\BOOKMARK [2][]{subsection.4.4.4}{4.4.4 Software de configuración}{section.4.4}% 65
\BOOKMARK [2][]{subsection.4.4.5}{4.4.5\040APIs}{section.4.4}% 66
\BOOKMARK [3][]{subsubsection.4.4.5.1}{4.4.5.1\040Java}{subsection.4.4.5}% 67
\BOOKMARK [3][]{subsubsection.4.4.5.2}{4.4.5.2\040C#}{subsection.4.4.5}% 68
\BOOKMARK [1][]{section.4.5}{4.5\040Resumen}{chapter.4}% 69
\BOOKMARK [0][]{chapter.5}{5 Evaluación técnica y pruebas de concepto}{}% 70
\BOOKMARK [1][]{section.5.1}{5.1 Evaluación aplicaciones nativa y multiplataforma}{chapter.5}% 71
\BOOKMARK [2][]{subsection.5.1.1}{5.1.1\040Prototipo\0403\040:\040Droid\040-\040Galaxy}{section.5.1}% 72
\BOOKMARK [3][]{subsubsection.5.1.1.1}{5.1.1.1\040Motores}{subsection.5.1.1}% 73
\BOOKMARK [3][]{subsubsection.5.1.1.2}{5.1.1.2\040Flexores}{subsection.5.1.1}% 74
\BOOKMARK [2][]{subsection.5.1.2}{5.1.2\040Prototipo\0404:\040Xamarin\040-\040Galaxy}{section.5.1}% 75
\BOOKMARK [3][]{subsubsection.5.1.2.1}{5.1.2.1\040Motores}{subsection.5.1.2}% 76
\BOOKMARK [3][]{subsubsection.5.1.2.2}{5.1.2.2\040Flexores}{subsection.5.1.2}% 77
\BOOKMARK [2][]{subsection.5.1.3}{5.1.3\040Prototipo\0403\040:\040Droid\040-\040Nexus}{section.5.1}% 78
\BOOKMARK [3][]{subsubsection.5.1.3.1}{5.1.3.1\040Motores}{subsection.5.1.3}% 79
\BOOKMARK [3][]{subsubsection.5.1.3.2}{5.1.3.2\040Flexores}{subsection.5.1.3}% 80
\BOOKMARK [2][]{subsection.5.1.4}{5.1.4\040Prototipo\0404:\040Xamarin\040-\040Nexus}{section.5.1}% 81
\BOOKMARK [3][]{subsubsection.5.1.4.1}{5.1.4.1\040Motores}{subsection.5.1.4}% 82
\BOOKMARK [3][]{subsubsection.5.1.4.2}{5.1.4.2\040Flexores}{subsection.5.1.4}% 83
\BOOKMARK [1][]{section.5.2}{5.2 Evaluación tiempo de activación usando APIs}{chapter.5}% 84
\BOOKMARK [2][]{subsection.5.2.1}{5.2.1\040API\040C#}{section.5.2}% 85
\BOOKMARK [2][]{subsection.5.2.2}{5.2.2\040API\040Java}{section.5.2}% 86
\BOOKMARK [1][]{section.5.3}{5.3 Evaluación tiempo de lectura de datos usando APIs}{chapter.5}% 87
\BOOKMARK [2][]{subsection.5.3.1}{5.3.1\040API\040C#}{section.5.3}% 88
\BOOKMARK [2][]{subsection.5.3.2}{5.3.2\040API\040Java}{section.5.3}% 89
\BOOKMARK [1][]{section.5.4}{5.4\040Pruebas\040de\040concepto}{chapter.5}% 90
\BOOKMARK [1][]{section.5.5}{5.5\040Resumen}{chapter.5}% 91
\BOOKMARK [0][]{chapter.6}{6\040Conclusiones}{}% 92
\BOOKMARK [1][]{section.6.1}{6.1\040Objetivos}{chapter.6}% 93
\BOOKMARK [2][]{subsection.6.1.1}{6.1.1 Objetivos específicos}{section.6.1}% 94
\BOOKMARK [3][]{subsubsection.6.1.1.1}{6.1.1.1 Desarrollar la aplicación de configuración de OpenGlove en Android. Permitiendo la creación, visualización, actualización y eliminación de los perfiles de configuración:}{subsection.6.1.1}% 95
\BOOKMARK [3][]{subsubsection.6.1.1.2}{6.1.1.2 Desarrollar APIs en Java y C# que permitan la administración de dispositivos Bluetooth en segundo plano en Android permitiendo la conexión, desconexión, activación y listado de guantes OpenGlove. También permitirá la activación y control de actuadores, flexores e IMU}{subsection.6.1.1}% 96
\BOOKMARK [3][]{subsubsection.6.1.1.3}{6.1.1.3\040Realizar\040evaluaciones\040de\040rendimiento\040para\040las\040APIs\040Java\040y\040C#\040:}{subsection.6.1.1}% 97
\BOOKMARK [3][]{subsubsection.6.1.1.4}{6.1.1.4\040Demostrar\040el\040uso\040del\040SDK\040en\040un\040ambiente\040de\040VR,\040AR\040o\040MR,\040utilizando\040las\040APIs\040desarrolladas:}{subsection.6.1.1}% 98
\BOOKMARK [2][]{subsection.6.1.2}{6.1.2\040Objetivo\040general}{section.6.1}% 99
\BOOKMARK [1][]{section.6.2}{6.2\040Resultados\040obtenidos}{chapter.6}% 100
\BOOKMARK [2][]{subsection.6.2.1}{6.2.1\040Desarrollo\040de\040software}{section.6.2}% 101
\BOOKMARK [2][]{subsection.6.2.2}{6.2.2\040Resultados\040de\040las\040pruebas}{section.6.2}% 102
\BOOKMARK [1][]{section.6.3}{6.3\040Alcances\040y\040limitaciones}{chapter.6}% 103
\BOOKMARK [1][]{section.6.4}{6.4\040Trabajo\040futuro}{chapter.6}% 104
\BOOKMARK [1][]{section.6.5}{6.5\040Observaciones\040finales}{chapter.6}% 105
\BOOKMARK [0][]{section.6.5}{Glosario}{}% 106
\BOOKMARK [0][]{chapter*.87}{Referencias bibliográficas}{}% 107
\BOOKMARK [0][]{chapter*.88}{Anexos}{}% 108
\BOOKMARK [0][]{chapter.1}{A\040\040Low\040Level\040Communication\040Protocol}{}% 109
\BOOKMARK [0][]{chapter.2}{B\040High\040Level\040Communication\040Protocol}{}% 110
\BOOKMARK [0][]{chapter.3}{C\040High\040Level\040OpenGlove\040APIs\040Reference}{}% 111
\BOOKMARK [1][]{section.3.1}{C.1\040C#\040API}{chapter.3}% 112
\BOOKMARK [1][]{section.3.2}{C.2\040Java\040API}{chapter.3}% 113
\BOOKMARK [0][]{chapter.4}{D\040Proof\040of\040concepts}{}% 114
